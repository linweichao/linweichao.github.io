<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>RabbitMQ教程 - Hello World - 林伟超</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="linweichao" /><meta name="description" content="文章来源于对官方文档的翻译。 先决条件 这个教程假设RabbitMQ安装和运行在localhost在标准端口上（5672）。使用了不同主机，端口" /><meta name="keywords" content="个人, 技术, 博客" />






<meta name="generator" content="Hugo 0.69.0 with theme even" />


<link rel="canonical" href="http://example.org/post/rabbitmq/rabbitmq%E6%95%99%E7%A8%8B-hello-world/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.8c3cbcb0324c2bb4875ceccba4007cbad4b4ac8377f33af9953c3e7684534a50.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="RabbitMQ教程 - Hello World" />
<meta property="og:description" content="文章来源于对官方文档的翻译。 先决条件 这个教程假设RabbitMQ安装和运行在localhost在标准端口上（5672）。使用了不同主机，端口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/post/rabbitmq/rabbitmq%E6%95%99%E7%A8%8B-hello-world/" />
<meta property="article:published_time" content="2020-05-24T10:15:28+08:00" />
<meta property="article:modified_time" content="2020-05-24T10:15:28+08:00" />
<meta itemprop="name" content="RabbitMQ教程 - Hello World">
<meta itemprop="description" content="文章来源于对官方文档的翻译。 先决条件 这个教程假设RabbitMQ安装和运行在localhost在标准端口上（5672）。使用了不同主机，端口">
<meta itemprop="datePublished" content="2020-05-24T10:15:28&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-24T10:15:28&#43;08:00" />
<meta itemprop="wordCount" content="2922">



<meta itemprop="keywords" content="翻译," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RabbitMQ教程 - Hello World"/>
<meta name="twitter:description" content="文章来源于对官方文档的翻译。 先决条件 这个教程假设RabbitMQ安装和运行在localhost在标准端口上（5672）。使用了不同主机，端口"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">林伟超</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">所有文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">目录</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">林伟超</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">所有文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">目录</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">RabbitMQ教程 - Hello World</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-05-24 </span>
        <div class="post-category">
            <a href="/categories/rabbitmq/"> RabbitMQ </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#先决条件">先决条件</a></li>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#hello-world">&ldquo;Hello World&rdquo;</a>
      <ul>
        <li><a href="#使用java客户端">（使用Java客户端）</a></li>
        <li><a href="#发送">发送</a></li>
        <li><a href="#接收">接收</a></li>
        <li><a href="#把所有东西放在一起">把所有东西放在一起</a></li>
      </ul>
    </li>
    <li><a href="#生产非适用性免责声明">生产（非）适用性免责声明</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>文章来源于对<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">官方文档</a>的翻译。</p>
<h2 id="先决条件">先决条件</h2>
<p>这个教程假设RabbitMQ安装和运行在<code>localhost</code>在标准端口上（<code>5672</code>）。使用了不同主机，端口和认证信息的情况下，连接设置需要调整。</p>
<h2 id="介绍">介绍</h2>
<p>RabbitMQ是一个消息代理（message broker）:它接收和发送消息。你可以把它想成是一个邮局：当你把要寄的邮件放进邮箱时，你可以确定邮递员先生或女士最终会把邮件投递给接收人。在这个类比中，RabbitMQ是邮箱，邮局和邮递员。</p>
<p>RabbitMQ和邮局的主要区别是它不处理纸张，而是接收、存储和发送二进制大数据 - 消息。</p>
<p>RabbitMQ，和消息通常使用一些术语。</p>
<ul>
<li>生产（producing）的意思不过是发送（sending）。一个发送消息的程序是一个生产者（producer）：</li>
</ul>
<p><img src="/RabbitMQ/tutorial-one/producer.webp" alt="producer"></p>
<ul>
<li>队列（queue）是RabbitMQ中邮箱的名字。尽管消息在RabbitMQ和程序之间流动，它们只能存储在队列中。队列只受限于主机的内存和磁盘限制，它本质上是一个大的消息缓冲。许多生产者可以发送消息到一个队列，许多消费者可以从一个队列中尝试接收数据。这是我们如何表示一个队列：</li>
</ul>
<p><img src="/RabbitMQ/tutorial-one/queue.webp" alt="queue"></p>
<ul>
<li>消费（consuming）跟接收的意思相似。一个消费者（consumer）是一个主要等待接收消息的程序：</li>
</ul>
<p><img src="/RabbitMQ/tutorial-one/consumer.webp" alt="consumer"></p>
<p>注意生产者，消费者和代理不必在同一台主机上；实际上在大部分程序中都不是。一个程序可以同时是生产者和消费者。</p>
<h2 id="hello-world">&ldquo;Hello World&rdquo;</h2>
<h3 id="使用java客户端">（使用Java客户端）</h3>
<p>在该教程的这一部分，我们会使用Java写两个程序；一个生产者发送一条消息，和一个消费者接收消息然后打印。我们会掩盖在Java API中的一些细节，集中在这些非常简单的事情上仅仅为了开始。这是消息中的&quot;Hello World&rdquo;。</p>
<p>在下面的图像中，”P“是我们的生产者，”C“是消费者。中间的箱子是队列 - RabbitMQ代表消费者保持的一个消息缓冲。</p>
<p><img src="/RabbitMQ/tutorial-one/python-one.webp" alt="app"></p>
<h4 id="java客户端库">Java客户端库</h4>
<p>RabbitMQ支持多种协议。该教程使用AMQP 0-9-1，是一个开放，通用目的的消息协议。在<a href="https://rabbitmq.com/devtools.html">多个不同语言中</a>有许多RabbitMQ的客户端。我们会使用RabbitMQ提供的Java客户端。</p>
<p>下载客<a href="https://repo1.maven.org/maven2/com/rabbitmq/amqp-client/5.7.1/amqp-client-5.7.1.jar">户端库</a>,和它的依赖（SLF4J API和 SLF4J Simple）。复制这些文件到你的工作目录，和教程中的Jva文件一起。</p>
<p>请注意SLF4J Simple对教程来说足够了，但应该在生产中使用成熟的日志库如Logback。</p>
<p>（RabbitMQ Java客户端也在Maven中央仓库中，groupId是com.rabbitmq，artifactId是amqp-client）。</p>
<p>现在我们有Java客户端和它的依赖，可以写一些代码了。</p>
<h3 id="发送">发送</h3>
<p><img src="/RabbitMQ/tutorial-one/sending.webp" alt="sending"></p>
<p>我们把消息发布者（发送者）叫做<code>Send</code>,消息消费者(接收者)叫做<code>Recv</code>。发布者会连接到RabbitMQ，发送一条消息，然后退出。</p>
<p>在<code>Send.java</code>中我们需要导入一些类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">com.rabbitmq.client.ConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.rabbitmq.client.Connection</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.rabbitmq.client.Channel</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>设置这个类和命名队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Send</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">argv</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
      <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>然后创建一个到服务器的连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>
<span class="k">try</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
     <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">())</span> <span class="o">{</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>连接抽象了socket连接，关心协议版本协商和认证等等。这里我们连接到本地机器上的代理 - 因此是localhost。如果想连接到不同机器上的代理，简单地指定它的名字或IP地址就行。</p>
<p>接下来创建了一个通道（channel），大多数完成任务的API都在其中。注意我们可以使用try-with-resources语句，因为<code>Connection</code>和<code>Channel</code>实现了<code>java.io.Closeable</code>。这种方式我们不需要在代码中明确地关闭它们。</p>
<p>为了发送，我们必须声明一个队列；然后我们可以发送消息到这个队列，所有这些都在try-with-resources语句中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">QUEUE_NAME</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="o">;</span>
<span class="n">channel</span><span class="o">.</span><span class="na">basicPublish</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">QUEUE_NAME</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">message</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34; [x] Sent &#39;&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;&#39;&#34;</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>声明队列是幂等的 - 只有不存在时才会创建。消息内容是一个字节数组，因此你可以在这里编码任何喜欢的。</p>
<p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/Send.java">这是完整的Send.java类</a>。</p>
<h4 id="发送不能工作">发送不能工作！</h4>
<p>如果这是你第一次使用RabbitMQ，并且没有看到发送的消息，那么你可能抓着自己的头想知道哪里可能出错了。可能代理没有足够的硬盘空间启动（默认至少200 MB可用）因此拒绝接收消息。检查代理的日志文件确认和按需减小限制。<a href="https://www.rabbitmq.com/configure.html#config-items">配置文件文档</a>会展示如何设置<code>disk_free_limit</code>。</p>
<h3 id="接收">接收</h3>
<p>这是我们的发布者。我们的消费者从RabbitMQ中监听消息，因此不像发布者发送一个消息，我们会保持它的运行来监听消息和打印出来。</p>
<p><img src="/RabbitMQ/tutorial-one/receiving.webp" alt="receiving"></p>
<p>代码（在<code>Recv.java</code>）和<code>Send</code>有着几乎一样的导入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">com.rabbitmq.client.Channel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.rabbitmq.client.Connection</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.rabbitmq.client.ConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.rabbitmq.client.DeliverCallback</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>我们会使用额外的<code>DeliverCallback</code>接口来缓冲服务器推送（push）给我们的消息。</p>
<p>设置和发布者一样；打开一个连接和一个通道，然后声明将要从中消费的队列。注意这和<code>Send</code>发送的队列相匹配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Recv</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">QUEUE_NAME</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">argv</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">ConnectionFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectionFactory</span><span class="o">();</span>
    <span class="n">factory</span><span class="o">.</span><span class="na">setHost</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">);</span>
    <span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newConnection</span><span class="o">();</span>
    <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createChannel</span><span class="o">();</span>

    <span class="n">channel</span><span class="o">.</span><span class="na">queueDeclare</span><span class="o">(</span><span class="n">QUEUE_NAME</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34; [*] Waiting for messages. To exit press CTRL+C&#34;</span><span class="o">);</span>

  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意这里我们也声明了队列。因为我们可能在发布者之前启动消费者，我们想确保队列在我们尝试从中消费之前就存在。</p>
<p>为什么不使用try-with-resources语句自动关闭channel和connection？这样做我们会简单地让程序继续，关闭所有，让后退出！这会很尴尬，因为我们想让这个进程在消费者异步监听消息到来时保运行。</p>
<p>我们将要告诉服务器从队列中分发消息给我们。由于它会异步给我们推送（push）消息，我们以对象的形式提供了一个回调，会缓冲消息直到我们准备使用它们。这就是<code>DeliverCallback</code>子类所做的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DeliverCallback</span> <span class="n">deliverCallback</span> <span class="o">=</span> <span class="o">(</span><span class="n">consumerTag</span><span class="o">,</span> <span class="n">delivery</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">delivery</span><span class="o">.</span><span class="na">getBody</span><span class="o">(),</span> <span class="s">&#34;UTF-8&#34;</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34; [x] Received &#39;&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&#34;&#39;&#34;</span><span class="o">);</span>
<span class="o">};</span>
<span class="n">channel</span><span class="o">.</span><span class="na">basicConsume</span><span class="o">(</span><span class="n">QUEUE_NAME</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">deliverCallback</span><span class="o">,</span> <span class="n">consumerTag</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">});</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/java/Recv.java">这是完整的Recv.java类。</a></p>
<h3 id="把所有东西放在一起">把所有东西放在一起</h3>
<p>你可以编译它们，只需要RabbitMQ java客户端在类路径中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">javac -cp amqp-client-5.7.1.jar Send.java Recv.java
</code></pre></td></tr></table>
</div>
</div><p>要运行的话，需要<code>rabbitmq-client.jar</code>和它的依赖在类路径中。在一个终端中，运行消费者（接收者）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">java -cp .:amqp-client-5.7.1.jar:slf4j-api-1.7.26.jar:slf4j-simple-1.7.26.jar Recv
</code></pre></td></tr></table>
</div>
</div><p>然后，运行发布者（发送者）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">java -cp .:amqp-client-5.7.1.jar:slf4j-api-1.7.26.jar:slf4j-simple-1.7.26.jar Send
</code></pre></td></tr></table>
</div>
</div><p>在Windows中，使用冒号替代分号分隔类路径中的项。</p>
<p>消费者会打印通过RabbitMQ从发布者获取到的消息。消费者会保持运行，等待消息（使用Ctrl-C停止它），因此尝试从另一个终端运行发布者。</p>
<h4 id="列出队列">列出队列</h4>
<p>你可能希望查看RabbitMQ有什么队列并且其中有多少消息。你可以使用<code>rabbitmqctl</code>工具做到（作为一个有特权的用户）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">sudo rabbitmqctl list_queues
</code></pre></td></tr></table>
</div>
</div><p>在Windows中，忽略sudo：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">rabbitmqctl.bat list_queues
</code></pre></td></tr></table>
</div>
</div><p>是时候继续到<a href="http://example.org/post/rabbitmq/rabbitmq%E6%95%99%E7%A8%8B-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/">第二部分</a>，构建一个简单的<em>工作队列（work queue）</em>。</p>
<h4 id="提示">提示</h4>
<p>为了减少打字，你可以为类路径设置环境变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">CP</span><span class="o">=</span>.:amqp-client-5.7.1.jar:slf4j-api-1.7.26.jar:slf4j-simple-1.7.26.jar
java -cp <span class="nv">$CP</span> Send
</code></pre></td></tr></table>
</div>
</div><p>或者在Windows中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">set</span> <span class="nv">CP</span><span class="o">=</span>.<span class="p">;</span>amqp-client-5.7.1.jar<span class="p">;</span>slf4j-api-1.7.26.jar<span class="p">;</span>slf4j-simple-1.7.26.jar
java -cp %CP% Send
</code></pre></td></tr></table>
</div>
</div><h2 id="生产非适用性免责声明">生产（非）适用性免责声明</h2>
<p>请记住这篇和其它教程，嗯，只是教程。它们一次演示了一个新的概念，可能故意过度简化某些事，忽略其它。例如连接管理，错误处理，连接恢复，并发和metric（不知道如何翻译，指的应该是如吞吐量等信息）收集的主题被大量忽略，为了简洁。如此简化的代码不应该认为是生产就绪的。</p>
<p>在使用你的程序之前，请看一看其余的<a href="https://www.rabbitmq.com/documentation.html">文档</a>。我们尤其推荐下面的指南： <a href="https://www.rabbitmq.com/confirms.html">Publisher Confirms and Consumer Acknowledgements</a>, <a href="https://www.rabbitmq.com/production-checklist.html">Production Checklist</a> 和 <a href="https://www.rabbitmq.com/monitoring.html">Monitoring</a>.</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">linweichao</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-05-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/rabbitmq/rabbitmq%E6%95%99%E7%A8%8B-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">RabbitMQ教程 - 工作队列</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/kafka/kafka%E4%BB%8B%E7%BB%8D/">
            <span class="next-text nav-default">Kafka介绍</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="http://example.org/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">linweichao</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
